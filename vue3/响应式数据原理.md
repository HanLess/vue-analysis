
<a href="https://segmentfault.com/a/1190000020629159">一张图理清 Vue 3.0 的响应式系统</a>

## 初始化阶段

#### 把响应数据的对象（data）转为 Proxy 代理

通过 reactive 方法可以将普通对象转为 proxy

```
const state = reactive({
    count: 0,
    age: 18
})
```

源码在 reactive.ts 中 

```
export function reactive(target: object) {
  ...
  return createReactiveObject(
    target,
    rawToReactive,
    reactiveToRaw,
    mutableHandlers,
    mutableCollectionHandlers
  )
}
```

```
function createReactiveObject(
  target: any,
  toProxy: WeakMap<any, any>,
  toRaw: WeakMap<any, any>,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
    ...
    
    const handlers = collectionTypes.has(target.constructor)
        ? collectionHandlers
        : baseHandlers
      observed = new Proxy(target, handlers)
      toProxy.set(target, observed)
      toRaw.set(observed, target)
      if (!targetMap.has(target)) {
        targetMap.set(target, new Map())
      }
      return observed
  
  ...
}
```

handlers 源码在 baseHandlers.ts 中，设置了 get , set , deleteProperty , has , ownKeys 五个属性

#### 通过 effect 可以设置数据响应后的回调

```
const effect1 = effect(() => {
    console.log('effect1: ' + state.count)
})
```

当 state.count 变化时，会触发执行

```
() => {
    console.log('effect1: ' + state.count)
}
```




## 收集依赖阶段



## 响应阶段
